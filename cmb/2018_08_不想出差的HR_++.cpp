/*
https://www.nowcoder.com/questionTerminal/e81c8d4652ea4d72abd94d8e443b8ee7?f=discussion

招商银行信用卡中心2018秋招开发方向笔试题


按照卡中心校园招聘的要求，HR小招和小商需要从三个科室中（分别为A、B、C）抽派面试官去往不同城市。
两名HR按照以下规定轮流从任一科室选择面试官：每次至少选择一位，至多选择该科室剩余面试官数。最先选不到面试官的HR需要自己出差。
假设HR小招和小商都不想出差且每次选择都采取最优策略，如果是小招先选，写一个函数来判断她是否需要出差。如果不需要出差，请给出第一步的最优策略。


输入1： 1 8 9
输出1： 1

输入2： 2 0 4
输出2： C,2


思路:
如果不知道博弈论里面的 Nim游戏，那么先解决边界情况

答案来自讨论区，思路解析可以参考这篇博客（全文附在最后）
https://blog.csdn.net/wu_tongtong/article/details/72860631




*/

#include <iostream>
#include <cmath>
#include <string>
using namespace std;

int main() {
    int a, b, c;
    char ch = ',';

    // cin 分隔符, 简单实用版
    // https://zhidao.baidu.com/question/45810663.html
    (cin >> a).get(ch);
    // 或者直接 (cin >> a).get();
    (cin >> b).get();
    (cin >> c).get();
    if ( a == 0 && b == 0 && c == 0 ) {
        cout << 1;
        return 0;
    }

    if ( a != 0 && b == 0 && c == 0 ) {
        cout << "A," << a;
        return 0;
    }

    if ( a == 0 && b != 0 && c == 0 ) {
        cout << "B," << b;
        return 0;
    }

    if ( a == 0 && b == 0 && c != 0 ) {
        cout << "C," << c;
        return 0;
    }

    string room[3] = {"A,", "B,", "C,"};
    int num[3] = {a, b, c};

    int k = a ^ b ^ c;
    if ( k == 0 ) {
        // 说明游戏开始前已经到达平衡态
        cout << 1;
    }
    else {
        for ( int i = 0; i < 3; i++ ) {
            int n = k ^ num[i];
            // n = k ^ a
            // k ^ a == b ^ c
            // 相当于 b 和 c 综合后还剩下的非平衡态
            if ( num[i] - n < 0 ) {
                // a < n, 说明这个 n 超过了 a，拿不走那么多人，需要换一个方案
                continue;
            }
            // 否则, 拿走 a - n 这么多人, 即可使得剩下的三个房间处于平衡态
            cout << room[i] << num[i] - n;
            break;
        }
    }
    return 0;
}



/*
版权声明：本文为CSDN博主「Coco_T_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wu_tongtong/java/article/details/72860631

Nim游戏（初谈博弈）
https://blog.csdn.net/wu_tongtong/article/details/72860631


通常的Nim游戏的定义是这样的：有若干堆石子，每堆石子的数量都是有限的，
合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，
如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。


这游戏看上去有点复杂，先从简单情况开始研究吧。
如果轮到你的时候，只剩下一堆石子，
那么此时的必胜策略肯定是把这堆石子全部拿完一颗也不给对手剩，然后对手就输了。

如果剩下两堆不相等的石子，必胜策略是通过取多的一堆的石子将两堆石子变得相等，
以后如果对手在某一堆里拿若干颗，你就可以在另一堆中拿同样多的颗数，直至胜利。
如果你面对的是两堆相等的石子，那么此时你是没有任何必胜策略的，
反而对手可以遵循上面的策略保证必胜。

现在我们如何从两堆的取子策略扩展到任意堆数中呢？

首先来回忆一下，每个正整数都有对应的一个二进制数，
于是，我们可以认为每一堆硬币数由2的幂数的子堆组成。
这样，含有57枚硬币大堆就能看成是分别由数量为2^5、2^4、2^3、2^0的各个子堆组成。

现在考虑各大堆大小分别为N1，N2，……Nk的一般的Nim取子游戏。
将每一个数Ni表示为其二进制数（数的位数相等，不等时在前面补0）：

N1 = as … a1 a0

N2 = bs … b1 b0

......

Nk = ms … m1 m0

如果每一种大小的子堆的个数都是偶数，我们就称Nim取子游戏是平衡的，

而对应位相加是偶数的称为平衡位，否则称为非平衡位。

因此，Nim取子游戏是平衡的，当且仅当：

as + bs + … + ms 是偶数

......

a1 + b1 + … + m1 是偶数

a0 + b0 + … + m0是偶数

于是，我们就能得出获胜策略：

游戏人I能够在非平衡取子游戏中取胜，而游戏人II能够在平衡的取子游戏中取胜。

*我们以一个两堆硬币的Nim取子游戏作为试验。设游戏开始时游戏处于非平衡状态。
这样，游戏人I就能通过一种取子方式使得他取子后留给游戏人II的是一个平衡状态下的游戏，
接着无论游戏人II如何取子，再留给游戏人I的一定是一个非平衡状态游戏，如此反复进行，
当游戏人II在最后一次平衡状态下取子后，游戏人I便能一次性取走所有的硬币而获胜。
而如果游戏开始时游戏牌平衡状态，那根据上述方式取子，最终游戏人II能获胜。

下面应用此获胜策略来考虑 4堆 的Nim取子游戏。
其中各堆的大小分别为7，9，12，15枚硬币。
用二进制表示各数分别为：0111，1001，1100和1111。于是可得到如下一表：

7       0 1 1 1
9       1 0 0 1
12      1 1 0 0
15      1 1 1 1

由Nim取子游戏的平衡条件可知，此游戏是一个非平衡状态的取子游戏，
因此，游戏人I在按获胜策略进行取子游戏下将一定能够取得最终的胜利。
具体做法有多种，游戏人I可以从大小为12的堆中取走11枚硬币，使得游戏达到平衡（如下表），

7       0 1 1 1
9       1 0 0 1
1       0 0 0 1    12 - 11 = 1
15      1 1 1 1

之后，无论游戏人II如何取子，游戏人I在取子后仍使得游戏达到平衡。
同样的道理，游戏人I也可以选择大小为9的堆并取走5枚硬币而剩下4枚，
或者，游戏人I从大小为15的堆中取走13枚而留下2枚。

所以归根结底，Nim游戏的核心就是判断初始状态是不是平衡状态
非平衡状态先手必胜，平衡状态后手必胜

*/
